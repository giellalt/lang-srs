###############################################
# Test compilation for verbs (stems, affixes) #
###############################################

# May want to use this if symbol pairs grow - needs foma
#set lexc-align ON

read lexc verbstems.lexc
def Stems

read lexc verb_inner_affixes.lexc
def InnerAffixes

read lexc verb_middle_affixes.lexc
def MiddleAffixes

read lexc verb_outer_affixes.lexc
def OuterAffixes

# Mark prefix type (insert corresponding flags to the
# original prefixes we know to be present from the lexical entry.
# ab=cd_ef.gh => ab@P.PREFIX.OUTER@=cd@P.PREFIX.MIDDLE@_ef@P.PREFIX.INNER@.gh

def MarkPrefixes ~$["@P.PREFIX.OUTER@"|"@P.PREFIX.INNER@"|"@P.PREFIX.MIDDLE@"] .o.
                  "=" -> "@P.PREFIX.OUTER@" "=" , 
                  "_" -> "@P.PREFIX.MIDDLE@" "_" , 
                  "." -> "@P.PREFIX.INNER@" ".";

# Insert . (inner), _ (middle), and = (outer) if missing in the intermediate rep:
# tsiy > =_.tsiy
# ts'á=zíd > ts'á=_.zíd
# tsí=di.tł'á > tsí=_di.tł'á
# gu.blah > =_gu.blah
# gu_blah > =gu_.blah

# (1) No . > insert . after last marker (= or _), or in the beginning if none exists
# (2) No _ > insert _ (a) after =, if one exists, or (b) beginning
# (3) No = > insert at beginning

def InsInner  [..] -> "." || "_" _ ~$"." .#. .o. 
              [..] -> "." || "=" _ ~$"." .#. .o. 
              [..] -> "." || .#. _ ~$"." .#. ;

def InsMiddle [..] -> "_" || "=" _ ~$["_"] .#. .o. 
              [..] -> "_" || .#. _ ~$["_"] .#. ; 

def InsOuter  [..] -> "=" || .#. _ ~$["="] .#. ;

# We temporarily keep the boundary symbol for inner affixes (".") in place
# so that we can target morphophonology there more easily (especially when
# aiming to drop the "weak" /i/ vowels that appear in inner lexical prefixes).
read regex Stems .o. MarkPrefixes .o. InsInner .o. InsMiddle .o. InsOuter .o. 
#            "." -> InnerAffixes , "_" -> MiddleAffixes , "=" -> OuterAffixes;
            "." -> "." InnerAffixes , "_" -> MiddleAffixes , "=" -> OuterAffixes;

twosided flag-diacritics
def Grammar;

#
# TODO: Move these morphophonological rules out to a separate script once
# they've been more extensively tested.
#
#source morphophonology.foma
#define morphophonology;

def vowel [a|ā|á|à|i|ī|í|ì|o|ō|ó|ò|u|ū|ú|ù];
def unmarkedVowel [a|i|o|u];
def consonant [b|c|d|g|h|j|k|l|ł|m|n|p|s|t|w|x|y|z|ʔ|%'];

# Change ua -> wa (general phonological process; phonetically, /wa/ can be
# realized as /wa/ or /ɔa/~/ɔˑ/, but this isn't represented orthographically)
def uBeforeA u -> w || _ [a|á|à];

# Change ái -> áa, áí -> áá, ài -> àà, ai -> aa. (TODO: check this against 
# more examples, especially ài -> àà, which may vary between speakers. For
# now, use this and see if we run into any problems with any of our test
# cases.)
def aBeforeI i -> a, í -> á || [a|á] _;
def lowABeforeI ì ì -> à, i -> à, í -> á || à _;

# Change szh -> sh (mách'ìguniszhoh -> mách'ìgunisshoh) (This rule may need to
# change; some people prefer to spell these forms without the second /s/)
def zhDevoicing z -> s || s _ h;

# Change sz -> ss (dìszày -> dìssày) (This rule may need to change; some
# people prefer to spell these forms without the second /s/)
def zDevoicing z -> s || s _;

# Remove any "weak" /i/ vowels from inner prefixes. (This makes it easier
# to combine inner prefixes with our inner inflectional chunks -- we can
# still provide the inner prefixes in our lexical entries as having vowels,
# but can remove them before we end up with sequences of three "iii"s in
# some inflected forms)
def deletePrefixI i -> 0 || _ "." vowel;
def deleteBoundarySymbol "." -> 0;

# Stems that begin with /l/ combine with 2PL (a|à)s- to form (a|à)ł (e.g.,
# /as+lí/ "you.PL are" -> [ałí]).  Rather than target flag diacritics here,
# we instead use the symbol 'S' to represent the /s/ in any 2PL inflectional
# chunks that are involved in this process.
def lInitialStemsSbjPl2 S l -> ł;
def lInitialStemsSbjPl2Cleanup S -> s;

# Phonotactic restriction: in general, /sl/ sequences should be resolved as
# /stł/ (e.g., /is+lí/ "I am" -> [istłí]), outside of 2PL forms.
def slDissimilation s l -> s t ł;

# Certain high-tone prefixes in Tsuut'ina (e.g., tsí- "flee", or í- from 
# historical *uˑ-) spread high tone rightward onto unmarked syllables,
# stopping at the first inflectional chunk (e.g., íts'idiyískid "they were
# asked" comes out as íts'ídíyískid, with high tone spreading from í- onto
# ts'i- and di-, but stopping at yi-).  We mark this spreading high tone
# in lexical entries as an H after the vowel (e.g., tsíH, íH)
#
# TODO: For now, this rule applies to sequences of at most three unmarked
# syllables that appear after a spreading H tone.  If it turns out that
# there are words with a spreading H tone that involve more than three
# unmarked syllables before the inflectional chunk, this rule will need to
# change.
def hToneSpreading a a -> á á, a -> á, i i -> í í, i -> í, o o -> ó ó, o -> ó, u u -> ú ú, u -> ú || H (consonant)+ _, H (consonant)+ (unmarkedVowel)+ (consonant)+ _, H (consonant)+ (unmarkedVowel)+ (consonant)+ (unmarkedVowel)+ (consonant)+ _;
def hToneSpreadingCleanup H -> 0;

read lexc verbtags.lexc
define Tags;

# To prevent morphophonology to be tripped up be intervening flags
set flag-is-epsilon ON

#regex Grammar Tags;
regex [Grammar Tags] .o. deletePrefixI .o. hToneSpreading .o. hToneSpreadingCleanup .o. deleteBoundarySymbol .o. uBeforeA .o. aBeforeI .o. lowABeforeI .o. lInitialStemsSbjPl2 .o. lInitialStemsSbjPl2Cleanup .o. slDissimilation .o. zhDevoicing .o. zDevoicing;

#eliminate flag TAMA
#eliminate flag SUBJECTNUMBER
#eliminate flag SUBJECTPERSON
#eliminate flag DISTRIBUTIVE
#eliminate flag OBJECTNUMBER
#eliminate flag OBJECTPERSON
#eliminate flag VALENCE
#eliminate flag PREFIX
#eliminate flag ASPECT
